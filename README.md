# COP4520A3
# Minotaur's Birthday Party

This program simulates a scenario where four helpers assist the Minotaur in sorting gifts and writing "Thank you" cards. It uses a concurrent linked list to manage the gifts and ensures that the tasks are completed efficiently and correctly.

## How It Works

The program creates four threads, each representing a helper. These threads perform tasks concurrently, such as adding gifts to a sorted linked list, writing "Thank you" cards, and locating specific gifts. The actions are synchronized to prevent data inconsistencies in the shared linked list.

## Improvements Over Basic Scenario

- **Concurrency**: Utilizes multithreading to allow simultaneous processing of tasks, speeding up the overall process.
- **Synchronization**: Ensures data consistency and prevents race conditions by using synchronized blocks for modifying shared resources.
- **Efficiency**: Implements efficient insertion in the linked list to maintain order and provides an effective way of handling tasks dynamically.
- **Flexibility**: Each thread can independently decide which task to perform next, reducing idle time and increasing responsiveness.
- **Debugging and Monitoring**: Includes console output statements to track the progress and actions of each helper, aiding in debugging and monitoring the process.

## Running the Program
1. Open a terminal or command prompt.
2. Navigate to the directory containing the file.
3. Compile the Java program:
   ```
   javac MinotaurBirthdayParty.java
   ```
4. Run the compiled program:
   ```
   java MinotaurBirthdayParty
   ```

## Proof of Correctness

- **Consistent Output**: The program consistently handles 500,000 gifts, ensuring each one is added to the list, processed for a "Thank you" card, and can be located, with no gifts lost or unaccounted for.
- **Synchronization**: The use of `synchronized` blocks ensures that multiple threads can work with the shared linked list without causing inconsistencies or corrupting the data structure.
- **Efficient Task Management**: The program completes the processing of all gifts efficiently, with each helper effectively managing tasks without unnecessary delays or idle time.

# Atmospheric Temperature Reader Simulation

This Java program simulates the atmospheric temperature monitoring module of a Mars Rover, designed to handle multiple temperature sensors recording data concurrently.

## Description

The program emulates 8 temperature sensors of a Mars Rover, each generating temperature readings between -100°F and 70°F at one-minute intervals. The readings are collected in a shared memory space. The module compiles a report every hour, showcasing the top 5 highest and lowest temperatures, and identifies the 10-minute interval with the largest temperature difference.

## Key Features

- **Concurrency**: Simulates 8 sensors operating concurrently, each running in its own thread, to mimic the multicore CPU environment of the Mars Rover.
- **Data Management**: Uses priority queues to maintain the top 5 highest and lowest temperatures, facilitating efficient data retrieval.
- **Thread Safety**: Implements a locking mechanism with `ReentrantLock` to ensure safe access to the shared data structure, preventing data corruption.

## How to Run
1. Copy the code into a file named `AtmosphericTemperatureReader.java`.
2. Compile the Java program by running:
   ```
   javac AtmosphericTemperatureReader.java
   ```
3. Execute the compiled class with:
   ```
   java AtmosphericTemperatureReader
   ```

## Testing and Proof of Correctness

- **Proof of Correctness**: The program's correctness is demonstrated by its consistent output, showing the highest and lowest temperature readings accurately after processing the simulated data. The use of `ReentrantLock` ensures that no readings are lost or overwritten, maintaining the integrity of the temperature data.
- **Efficient Data Handling**: The priority queues effectively manage the temperature readings, always keeping track of the top 5 extremes. This is validated by the consistent and accurate reports generated by the program.
- **Testing**: For quicker testing, you can reduce the sleep time in the sensor simulation loop. This will simulate the passing of time more rapidly. Adjust the `Thread.sleep(10000);` line in each sensor's run method to a smaller value (e.g., `1000` for one second) to simulate the entire hour more quickly.

## Simulation Output

- The program will display the top 5 highest and lowest temperature readings after simulating an hour of data collection.
- Temperature readings are inserted and managed in real-time, showcasing the program's ability to handle concurrent data processing efficiently.
